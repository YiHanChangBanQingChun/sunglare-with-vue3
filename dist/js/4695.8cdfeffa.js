"use strict";(self["webpackChunksun_glare_project"]=self["webpackChunksun_glare_project"]||[]).push([[4695],{84695:function(e,t,s){s.d(t,{uploadAssets:function(){return h}});s(44114);var a=s(86039),r=s(47966),n=s(15114),o=s(71120),i=s(4244),l=s(87993),u=s(81431),c=s(75122);const p=1e6,f=20*p,d=2e9,y=3;async function w({data:e,name:t,description:s},r,n){let l=null;try{const u=(0,i.fj)(r,"uploads"),w=(0,i.fj)(u,"info"),{data:m}=await(0,a["default"])(w,{query:{f:"json"},responseType:"json"});(0,o.Te)(n);const h=(0,c.Wo)(r),g=m.maxUploadFileSize*p,T=h?d:g,j=h?Math.min(f,g):f;if(e.size>T)throw new Error("Data too large");const A=(0,i.fj)(u,"register"),{data:b}=await(0,a["default"])(A,{query:{f:"json",itemName:t,description:s},responseType:"json",method:"post"});if((0,o.Te)(n),!b.success)throw new Error("Registration failed");const{itemID:E}=b.item;l=(0,i.fj)(u,E);const F=(0,i.fj)(l,"uploadPart"),$=Math.ceil(e.size/j),D=new Array;for(let t=0;t<$;++t)D.push(e.slice(t*j,Math.min((t+1)*j,e.size)));const v=D.slice().reverse(),N=new Array,U=async()=>{for(;0!==v.length;){const e=D.length-v.length,t=v.pop(),s=new FormData;s.append("f","json"),s.append("file",t),s.append("partId",`${e}`);const{data:r}=await(0,a["default"])(F,{timeout:0,body:s,responseType:"json",method:"post"});if((0,o.Te)(n),!r.success)throw new Error("Part upload failed")}};for(let e=0;e<y&&0!==v.length;++e)N.push(U());await Promise.all(N);const x=(0,i.fj)(l,"commit"),{data:S}=await(0,a["default"])(x,{query:{f:"json",parts:D.map(((e,t)=>t)).join(",")},responseType:"json",method:"post"});if((0,o.Te)(n),!S.success)throw new Error("Commit failed");return S.item}catch(u){if(null!=l){const e=(0,i.fj)(l,"delete");await(0,a["default"])(e,{query:{f:"json"},responseType:"json",method:"post"})}throw u}}var m=s(15433);async function h(e,t,s){return e.length?Promise.all(e.map((e=>g(e,t,s)))):[]}async function g(e,{layer:t,ongoingUploads:s},a){const n=s.get(e);if(n)return n;if(!C(t))throw new r.A(`${t.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);if(T(e,t))return e;const o=j(e,t,a);s.set(e,o);try{await o}finally{s.delete(e)}return e}function T(e,t){const{parsedUrl:s}=t;return null!=s&&e.metadata.externalSources.some((e=>(0,u.eN)(e,s)))}async function j(e,t,s){const{metadata:a}=e,{displaySource:r}=a,n=D(r?.source,t),i=!!n,l=a.externalSources.length>0,u=i?A(n,t,s):l?b(e,t,s):E(e,t,s),c=await u;return(0,o.Te)(s),e.addExternalSources([c]),e}async function A(e,t,s){return{source:await N(e,t,s),original:!0}}async function b(e,t,s){const a=B(t),{externalSources:n}=e.metadata,o=$(n,t);if(!o)throw new r.A(`${t.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const i=await N(o,t,s);return e.addExternalSources([{source:i,original:!0}]),{source:await R(i,t,a)}}async function E(e,t,s){const a=F(e,t,s);return{source:await U([a],t,s),extent:e.extent.clone(),original:!0}}async function F(e,t,s){const a=B(t),r=await e.load(s),n=await r.toBinaryGLTF({ignoreLocalTransform:!0});(0,o.Te)(s);const i=await n.buffer();return(0,o.Te)(s),{blob:new Blob([i.data],{type:i.type}),assetName:`${(0,l.y)()}.glb`,assetType:a}}function $(e,t){for(const s of e){const e=D(s.source,t);if(e)return e}return null}function D(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:a}}=t,r=(0,u.WN)(e),n=new Array;let o=!1;for(let i=0;i<r.length;++i){const e=v(r[i],s);if(!e)return null;a.includes(e.assetType)&&(o=!0),n.push(e)}return o?n:null}function v(e,t){const s=(0,u.fH)(e,t);return s?{asset:e,assetType:s}:null}async function N(e,t,s){return U(e.map((e=>x(e,s))),t,s)}async function U(e,t,s){const a=await Promise.all(e.map((async e=>{const a=S(await e,t,s);return(0,o.Te)(s),a})));(0,o.Te)(s);const{uploadResults:r}=await q(a.map((({item:e})=>e)),t,s);return(0,o.Te)(s),e.map(((e,s)=>P(a[s],r[s],t)))}async function x(e,t){const{asset:s,assetType:a}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:a};const r=await s.toBlob(t);return(0,o.Te)(t),{blob:r,assetName:s.assetName,assetType:a}}async function S(e,t,s){const{blob:a,assetType:l,assetName:u}=e;let c=null;try{const e=await w({data:a,name:u},t.url,s);(0,o.Te)(s),c={assetType:l,assetUploadId:e.itemID}}catch(p){(0,o.QP)(p),n.A.getLogger("geoscene.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${t.url} does not support the REST Uploads API.`)}if(!c){const e=await(0,i._0)(a);if((0,o.Te)(s),!e.isBase64)throw new r.A(`${t.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);c={assetType:l,assetData:e.data}}if(!c)throw new r.A(`${t.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return{item:c,assetName:u}}async function q(e,t,s){const n=await(0,a["default"])((0,i.fj)(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if((0,o.Te)(s),n.data.uploadResults.length!==e.length)throw new r.A(`${t.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${e.length} items and received ${n.data.uploadResults.length} results.`,new Error);return n.data}function P(e,t,s){const{success:a}=t;if(!a){const{error:a}=t;throw new r.A(`${s.type}-layer:upload-failure`,`Failed to upload mesh file ${e.assetName}. Error code: ${a.code}. Error message: ${a.messages}`,new Error)}const{assetHash:n}=t,{assetName:o,item:{assetType:i}}=e,{infoFor3D:{supportedFormats:l}}=s,c=(0,m.Fm)(i,l);if(!c)throw new r.A(`${s.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${i}, but it does not list it in its supported formats.`,new Error);return new u.Qp(o,c,[new u.Bq(`${s.parsedUrl.path}/assets/${n}`,n)])}async function R(e,t,s){const n=e.map((({assetName:e,parts:t})=>({assetName:e,assetHash:t[0].partHash}))),o=t.capabilities?.operations.supportsAsyncConvert3D,l={query:{f:"json",assets:JSON.stringify(n),transportType:"esriTransportTypeUrl",targetFormat:s,async:o},responseType:"json",timeout:0},c=(0,i.fj)(t.parsedUrl.path,"convert3D"),p=(o?await I(c,l):await(0,a["default"])(c,l)).data,{infoFor3D:{supportedFormats:f}}=t;return p.assets.map((e=>{const s=(0,m.R_)(e.contentType,f);if(!s)throw new r.A(`${t.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${s}, but it does not list it in its supported formats.`,new Error);return new u.Qp(e.assetName,e.contentType,[new u.Bq(e.assetURL,e.assetHash)])}))}async function I(e,t){const s=(await(0,a["default"])(e,t)).data.statusUrl;for(;;){const e=(await(0,a["default"])(s,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return(0,a["default"])(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new r.A("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new r.A("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await(0,o.Pl)(_)}}function C(e){return!!e.infoFor3D&&!!e.url}function B(e){const{infoFor3D:t}=e,s=(0,m.R_)("model/gltf-binary",t.supportedFormats)??(0,m.E1)("glb",t.supportedFormats);if(!s)throw new r.A(`${e.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return s}const _=1e3}}]);
//# sourceMappingURL=4695.8cdfeffa.js.map